---

layout: post

title: Hash를 이용한 문장 중복확인

date: 2021-05-22 21:05:23 +0900

categories: NLP

---

Hash
---

#### Hash란?

Hash란 다양한 크기의 데이터를 고정적인 크기를 가진 값으로 매핑하는 함수입니다.

즉 매핑이 이루어지기 전 값이 key라면 Hash(key)의 결과로 도출되는 것이 값(value)입니다.

$$Hash(key) = HValue$$

이 방식을 이용한 예시와 순서에 대해 공부해보겠습니다.

#### HashTable

Hash 방식을 이용하여 자료구조를 구현해낼 수 있습니다. 바로 Map과 같은 자료구조에서 사용 될 수 있는데, 그 순서는 다음과 같이 그려 볼 수 있습니다.

다음의 그림에서는 정수 혹은 문자열이나 파일과 같은 데이터를 기반으로 어떻게 데이터를 탐색 및 저장하는지에 대한 일련의 과정을 볼 수 있습니다.

<img src="/public/img/hashflow.jpeg" width="300" height="400">

1. 데이터를 Hash Function의 인자로 넣어 Hash Value를 얻습니다.
2. Hash Value를 Index를 얻을 수 있는 함수의 인자로 넣어 배열에 접근 할 위치인 Index를 얻습니다. [ 나머지를 이용하는 방법을 주로 사용 ]
3. Index를 이용하여 배열에 접근하여 값을 읽거나 저장한다.

이렇게 **Hash**라는 방법을 이용하여 배열의 사이즈가 저장되는 데이터에 비해 상당히 크다는 가정하에 평균 접근 시간이 O(1)인 자료구조를 만들 수 있습니다.

이 점을 기반으로 HashTable을 구현해보겠습니다.

#### HashTable 구현

```python
class HashObj:
    def __init__(self,hashValue,value):
        self.hashValue = hashValue
        self.value = value

    def is_equal(self,hashValue):
        if self.hashValue == hashValue:
            return True
        else:
            return False
    def getValue(self):
        return self.value
    def getHash(self):
        return self.hashValue


class Hash:

    def __init__(self,size=17):
        self.HashMinimum = 100000000
        self.size = size
        self.arr = [[] for i in range(size)]

    def setEqualHashSize(self,hashValue):
        return hashValue * (self.HashMinimum//hashValue +1 )

    def hashCode(self,key):
        return self.setEqualHashSize(sum(list(map(lambda x:(x[0]+1)*ord(x[1]) ,enumerate(key)) )))

    def hashFunction(self,key):
        return self.hashCode(key) % self.size

    def save(self,key,value):
#        self.arr[self.hashFunction(key)] = self.hashCode(key)
        self.arr[self.hashFunction(key)].append(HashObj(self.hashCode(key),value))

    def getArray(self):
        return self.arr

    def find(self,key):
        key_hash = self.hashCode(key)
        for hashobj in self.arr[self.hashFunction(key)]:
            if(hashobj.is_equal(key_hash)):
                return hashobj.getValue()

        return 'None'

```

HashTable을 통해 데이터를 추가와 조회하는 경우만을 가정하여 다음과 같은 코드를 작성했습니다.

실제로는 Hash Function은 동일한 크기의 Hash값을 리턴하는 것을 다른 방식으로 구현되어 있겠지만 저는 임시적으로 100000000을 넘는 값까지 곱하는 방식으로 간략하게 만들어보았습니다.

위의 값 이상의 값이 key로 주어진다면 자릿수 고정은 안되겠지만 일단은 key-value 형식을 구형해보았습니다.

결과를 한번 확인해보겠습니다.

```python
for i in range(0,50):
    a.save(str(i),'value'+str(i))
print(list(map(lambda x:len(x),a.getArray())))

# [6, 1, 2, 2, 2, 5, 2, 5, 3, 1, 4, 7, 0, 3, 1, 4, 2]
```

0부터 49까지의 숫자를 문자로 바꾸어 HashTable에 저장해보니 다음과 같은 결과가 나왔습니다. HashTable을 이용한 자료구조에서는 Index가 고르게 나오는 것이 효율적이라고 말할 수 있습니다.

예를 들어 위의 결과에서 11번째 위치에는 7개의 요소가 포함되어 있기 때문에 탐색하는데 7개의 요소를 확인해야합니다. 만약 50개의 요소가 한 key에 모여있다면 어떻게 될까요?

최악의 상황을 만들어봅시다!

```python
for i in range(0,350):
    if(a.hashFunction(str(i)) == 0):
        a.save(str(i),'value'+str(i))
print(list(map(lambda x:len(x),a.getArray())))

# [50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

저장 된 데이터가 50개지만 한 인덱스에 모여있는 것을 볼 수 있습니다. 그렇다면 우리는 특정 키에 대한 값을 찾기 위해서는 50번의 반복문을 수행해야합니다.

**이 경우가 최악의 탐색 효율인 O(n)의 예시입니다.**

즉 좋은 HashTable을 만들기 위해서는 좋은 hashFunction을 만들어야하고, 좋은 hashFunction은 Index를 고르게 분포시킬 수 있는 알고리즘이어야 합니다.

#### 문장의 해시

이 방식을 이용하여 문장을 기반으로 해시값을 얻어보는 작업을 수행해보겠습니다. 다양한 크기의 문장을 동일한 길이의 값으로 변환하는 것을 해시라고 공부를 했습니다. 이런 방식을 이용하여 Table형식으로 저장하는 방식또한 알아보았습니다.

우리가 하고 싶은 작업은 해당 문장과 동일한 혹은 유사한 문장이 해시 테이블 내에 있는가를 알아보는 것 입니다. 이 문제를 해결하기위해 다음과 같은 문제점이 있음을 꼽았습니다.

1. 문장의 벡터에 대한 해시값은 어느 정도의 크기를 가지는가? 혹은 해시 알고리즘 중 어떤 방식을 이용해야 하는가?
2. 키 - 값 형식의 1:N 매칭의 방식에서 유사함을 나타내기 위해 어떤 방식을 사용할 수 있는가?
3. 입력한 문장에 대해 유사 문장을 찾아가는 과정은 어떻게 진행되는가?

하나같이 난감한 질문 뿐입니다만, 저는 지금까지 공부해왔던 과정을 이용하여 다음의 문제를 해결해보고자 합니다.

##### 문장을 나타낼 수 있는 해시 알고리즘 탐색

가장 문제가 되는 부분입니다. 문장을 입력했을 때 해시 값을 얻을 수 있는 방법으로는 SHA 암호화 알고리즘이 있습니다.

백엔드 개발을 하면서 비밀번호 보안에서 사용한 경험은 있지만, 확실한 문제점으로는 64글자 정도의 해시값을 얻는데에 사용되며 너무 긴 문자열의 해시값을 얻기에는 무리가 있어 보입니다.

그래서 생각 한 방법은 **문장으로 학습해야하나?** 라는 의문에서 시작한 **기존에 구했던 벡터를 해시값으로 구해버리자!** 였습니다.

1. 상대적 출현 비율을 통한 키워드 추출
2. 단어의 벡터화
3. 단어 벡터를 이용한 문장의 벡터화
4. 문장의 벡터를 이용한 군집화
5. 대규모 데이터 처리가 가능한 스파크

지금까지 공부했던 이 5개의 방식을 이용하여 구현해보도록 하겠습니다.

추가적으로 적기! 임시 저장

- https://velog.io/@jisoo1170/해시Hash란-무언인가
